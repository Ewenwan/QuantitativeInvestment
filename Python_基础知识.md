
# 基本的数据类型
    在Python中，能够直接处理的数据类型有以下几种：
    
## 整数  int
    Python可以处理任意大小的整数，包括负整数，写程序的时候表述与数学上的方法一样，例如：99，-3，6666 等等。
## 浮点数 float
    浮点数也可以称为小数。叫做浮点数是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的。
    比如，1.11x106和11.1x105是完全相等的。对于很大或很小的浮点数，
    必须用科学计数法表示，把10用e替代，1.11x106就是1.11e6，或者11.1e5，0.0000011可以写成1.1e-6。
    负数的话直接在前面加负号即可，例如：-1.1e-6。
    
    需要注意的一点是，整数和浮点数在计算机内部存储的方式是不同的，整数之间的运算永远是精确的，
    而浮点数运算则可能会有四舍五入的误差。

## 字符串
    字符串是以单引号 ' 或双引号 " 括起来的任意文本' '或" "只是一种表示方式，不是字符串的一部分，
    所以字符串'rice'只有r，i，c，e这4个字符。如果要把'本身也包括进字符里，那就可以用" "括起来。
    如果字符串内部既包含 ' 又包含 " 怎么办呢？我们可以用转义字符 \ 来标识，
    如：'I\'m \"OK\"!'表示的内容为：I'm "OK"!
    转义字符\可以转义很多字符，比如\n表示换行，\t表示制表符，字符\本身也要转义，
    所以\表示的字符就是\，用print()打印字符串看看结果如何（3.0之后的版本要 + () ）：
    
    >>> print('I\'m OK')      I'm OK
    
## 布尔值
    布尔值和布尔代数的表示完全一致，一个布尔值只有True、False两种值。Python中，
    既可以直接用True、False表示（一定要大写），也可以通过布尔运算计算出来：
    >>> True
    True
    >>> 1>0
    True
    
    布尔值可以用and、or和not即 与、或和非进行运算。
    and 与 前后都为True 结果才为True  前面为False 后面的就不判断了
    or   或  前后有一个为 True 结果就为True  前面为 True后面的就不判断了
    not  非 取反  单目运算符
    
# 列表
    Python内嵌的数据类型主要包括以下两类：
    
    有序（底层红黑数存储结构）：
    
      1. List（列表） 
          是有序集合，没有固定大小，可以通过对偏移量以及其他方法修改列表大小。列表的基本形式如：[1,2,3,4]方括号
      2. Tuple（元组）
          是有序集合，是不可变的，可以进行组合和复制运算后会生成一个新的元组。元组的基本形式比如：(1,3,6,10)圆括号
      3. String（字符串）
          也是有序集合，字符串的基本形式比如：’hello’，这里不进行具体介绍。单引号 或 双引号

      List（列表） 是 Python 中最通用的序列。列表是一个任意类型对象位置的相关有序集合，它没有固定大小。
      不像字符串，其大小是可以变的，通过对偏移量进行赋值以及其他各种列表的方法进行调用，可以修改列表大小。
      
    无序（底层哈希表存储结构）：
      1. Set（集合）
        是一个无序不重复元素的集。基本功能包括关系运算和消除重复元素。集合的基本形式如：set('abracadabra')   
      2.dictionary（字典）
        是无序的键：值对  (key:value 对)集合，键必须是互不相同的(在同一个字典之内)。
        字典的基本形式如：{'jack': 4098, 'sape': 4139} 首先对列表进行介绍。
        
      索引是从0开始而非1开始！！ [ ） 左闭 右开
      
## 列表list  
    列表中值的分割用变量[头下标:尾下标]，就可以截取相应的列表，从左到右索引默认“0”开始的，从右到左索引默认-1开始，
    下标可以为空表示取到头或尾。可以对列表进行索引、切片等操作，看下面例子。
### 列出一周 可以使用list：
    >>> week = ['Monday','Tuesday','Wednesday','Thursday','Friday','Saturday','Sunday']   
    >>> week
     ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
### week是一个list，可以用len()获取其元素个数：
    >>> len(week)
      7
    可以使用索引来访问list中的每一个位置上的元素，不过一定要记住索引是从0开始的！！
    >>> week[0]
      'Monday'   
    >>> week[len(week)-1]    
      'Sunday'
      
     由于索引是从0开始的，最后一个元素的索引是列表长度 - 1。
    python支持从列表最后取元素，如果要取最后一个元素，可以用-1做索引，直接获取最后一个元素：
    >>> week[-1]
      'Sunday'
    >>> week[-7]
      'Monday'   
    
    
### 删除list末尾的元素，使用pop()方法：
    >>> week.pop()
      'Sunday'      返回被删除的元素  pop(i) 删除指定索引元素
    >>> week
      ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
      
### 由于list是一个可变的有序表，所以我们可以往list中 追加 append() 元素到末尾：
    >>> week.append('Sun')
    >>> week
      ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sun']  
      
### 还可以把元素插入 insert() 到指定的位置，比如索号为7的位置：
    >>> len(week)
      7
    >>> week.insert(7,'8')
    >>> week
      ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sun', '8']
    >>> len(week)
### 把某个元素替换成别的元素，可以直接赋值给对应的索引位置：
    >>> week[0]
      'Monday'
    >>> week[0]='1'
    >>> week[0]
      '1'
    >>> week
      ['1', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sun', '8']

### Python 的列表数据类型包含更多的方法。
    list.append(x)    把一个元素添加到列表的结尾。
    list.extend(L)    将一个给定列表中的所有元素都添加到另一个列表中。
    list.insert(i, x) 在指定位置插入一个元素。第一个参数是准备插入到其前面的那个元素的索引，
                      例如 a.insert(0, x) 会插入到整个列表之前，而 a.insert(len(a), x) 相当于 a.append(x)。
    list.remove(x) 删除列表中值为 x 的第一个元素。如果没有这样的元素，就会返回一个错误。
    list.pop([i]) 从列表的指定位置删除元素，并将其返回。如果没有指定索引，a.pop() 返回最后一个元素。
                  元素随即从链表中被删除。(方法中 i 两边的方括号表示这个参数是可选的，而不是要求你输入一对方括号，
                  这个经常会在 Python 库参考手册中遇到这样的标记。)
    list.index(x) 返回列表中第一个值为 x 的元素的索引。如果没有匹配的元素就会返回一个错误。
    list.count(x) 返回 x 在链表中出现的次数。
    list.sort(cmp=None, key=None, reverse=False) 对列表中的元素进行排序
                  参数可以用来自定义排序方法，参考 sorted() 的更详细的解释）。
    list.reverse() 就地倒排链表中的元素
    del list[i] 有个方法可以从列表中按给定的索引而不是值来删除一个子项：del 语句。
                 它不同于有返回值的 pop() 方法。语句 del 还可以从列表中删除切片或清空整个列表
                 我们以前介绍过一个方法是将空列表赋值给列表的切片 
  
  
## 元组（tuple）
    tuple是另一种有序的数据类型，与list比较类似。主要不同的一点是tuple被创建后就不能对其进行修改。
    所以，tuple与list不同，没有append(),pop(),insert()这些方法可以使用。
    获取元素的方法和list是一样的，可以通过索引来访问（也是从0开始的），只不过不能赋值成为其他的元素。
    因为tuple不可变，所以代码更安全。如果可以的话，我们尽量使用tuple代替list      
      
### 创造元组
    定义一个空的tuple，使用 () ：
    >>> t=()
    >>> t
    `()
    
    只有1个元素的元组在进行定义的时候，需要加一个逗号 , 来消除歧义，
    否则定义的就不是一个元组而是元素本身：
    >>> t=(3)
    >>> t
    `3
    >>> t=(3,)
    >>> t
    `(3, )

###   元组的连接
    如前面所说，元组是不可改的，但是可以连接
    可以使用 + 对元组进行连接，例如：
    >>> t1 =(2,3,5)
    >>> t1
     (2, 3, 5)
    >>> t2=('rice', 'mid')
    >>> t2
     ('rice', 'mid')
    >>> t3=t1+t2     底层重载了 +号运算符
    >>> t3
      (2, 3, 5, 'rice', 'mid')
      
### 元组的删除
    元组中的元素不能被删除，但是我们可以使用 del 删除整个元组，删除后可以重新定义：
    >>> t3[0]
    2
    >>> t3[0]=3  错误    >>>  del t3 
    
### 元组元素的间接修改
    事实上，上面所说的元素不变是指每个元素的指向永远不变。即指向1，就不能改成指向2，
    指向一个list，就不能改成指向其他对象，
    但指向的这个list本身是可变的，例如：
    
    >>> t4 = (1,2,[3,4,5])
    >>> t4
    (1, 2, [3, 4, 5])
    >>> t4[2][0]
    3
    >>> t4[2][0]=100
    >>> t4
    (1, 2, [100, 4, 5])

### Python 的元组数据类型包含更多的方法。
    tup.index(x, [start, [stop]])) 返回元组中start到stop索引中第一个值为 x 的元素在整个列表中的索引。
                                   如果没有匹配的元素就会返回一个错误。
    tup.count(x) 返回 x 在元组中出现的次数。
    cmp(tuple1, tuple2) 比较元组中两个元素。
    len(tuple) 计算元组元素个数。
    max(tuple) 返回元组中元素最大值。
    min(tuple) 返回元组中元素最小值。
    tuple(seq) 将列表转换为元组。
    
    元组不提供字符串、列表和字典中的方法。
    
    如果相对元组排序，通常先得将它转换为列表并使其成为一个可变对象，
    才能获得使用排序方法，或使用sorted内置方法。     
    
## 字典（dictionary）

    字典在某些语言中可能称为 联合内存 (associative memories) 或 联合数组 (associative arrays)。
    序列是以连续的整数为索引，与此不同的是，字典以"关键字"为索引，关键字可以是任意不可变类型，通常用字符串或数值。
    如果元组中只包含字符串和数字，它可以作为关键字，如果它直接或间接地包含了可变对象，就不能当做关键字。
    不能用列表做关键字，因为列表可以用索引、切割或者 append() 和 extend() 等方法改变。
    
### 字典的创建
    使用大括号创建一个空的字典：{}。
    >>> d ={}
    >>> d
      {} 
    初始化列表时，在大括号内放置一组逗号分隔的 键：值 对，
    这也是字典输出的方式。
    >>> d={'aline':50, 'dline':100}
    >>> d
     {'aline': 50, 'dline': 100}
     
    字典是无序的键：值对 (key:value 对)集合，
    键必须是互不相同的(在同一个字典之内)。      
      
### 字典的主要操作是依据键来存储 和 取值。

    >>> d['aline']
      50
    >>> d['aline'] =111
    >>> d
      {'aline': 111, 'dline': 100}   
### 用 del 来删除键：值对(key:value)，

    >>> del d['aline']
    >>> d
    {'dline': 100}
    
    >>> d['agg'] =1
    >>> d
    {'dline': 100, 'agg': 1}
    
    删除一个key，使用pop(key)方法，对应的value也会从dict中删除：
    >>> d.pop('dline')
    100
    >>> d
    {'agg': 1}


      
###  把数据放入dict还可以 

#### 直接通过key放入：
    >>> d['agg']=0.5
    >>> d
    {'dline': 100, 'agg': 0.5}

    一个key只能对应一个value，多次对一个key放入value，后面的值会把前面的值冲掉：
    >>> d['agg'] =1
    >>> d
    {'dline': 100, 'agg': 1}
    
####  如果key不存在，对key进行访问，dict就会报错。  
    要避免key不存在的错误，有两种办法，
    
    一是通过 in 判断key是否存在，
    
    二是通过dict提供的 get 方法，
    如果key不存在，可以返回None（返回None的时候Python的交互式命令行不显示结果），
    或者自己指定的value：
    >>> 'meet' in d
      False
    >>> d.get('agg')
     1
    >>> d.get('meet')
    >>> d.get('meet',20)    这种方式不会增加字典元素
      20
    >>> d
    {'dline': 100, 'agg': 1}

### 有下面几点需要注意：
    1. dict内部存放的顺序和key放入的顺序是没有关系的
    2. dict查找和插入的速度极快，不会随着key的增加而增加，但是需要占用大量的内存，内存浪费多
    3. dict的key必须是不可变对象。字符串、整数等都是不可变的，可以放心地作为key，而list是可变的，就不能作为key：

### 常见字典操作方法   
    D.clear()删除字典内所有元素
    D.copy()返回一个字典的复制
    D.fromkeys(seq,val)创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值
    D.get(key, default=None)返回指定键的值，如果值不在字典中返回default值
    D.has_key(key)如果键在字典dict里返回true，否则返回false
    
    D.items()以列表返回 可遍历的(键, 值)   元组数组
    
    D.keys()以列表返回一个字典所有的键
    D.setdefault(key, default=None)和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default
    D.update(dict2)把字典dict2的键/值对更新到dict里
    D.values()以列表返回字典中的所有值
    D.pop(key)删除一个键并返回它的值，类似于列表的pop,只不过删除的是一个键不是一个可选的位置
    del D[key]删除键
    D[key] = 42新增或修改键
    
### 字典用法注意事项：
    1. 序列运算无效，字典元素间是没有顺序的概念
    2. 对新索引赋值会添加项
    3. 键不一定总是字符串
    
### 多种构造字典方式
#### dict() 构造函数可以直接从 key-value 对中创建字典
    >>> d = dict([('frank',410),('usa',100),('cherman',200)])
    >>> d
      {'frank': 410, 'usa': 100, 'cherman': 200}

#### dict.fromkeys([‘apple’,’balala’],0)
    >>> dfruit = dict.fromkeys(['apple','balana'],0)
    >>> dfruit
      {'apple': 0, 'balana': 0}

#### zip() + dict() 方式
    >>> dalpha = dict(zip(['a','b','c'],[1,2,3]))
    >>> dalpha
      {'a': 1, 'b': 2, 'c': 3}

#### zip() + 范围for
    >>> dkv = {k:v for (k,v) in zip(['aa','bb','cc'],[11,22,33])}
    >>> dkv
      {'aa': 11, 'bb': 22, 'cc': 33} 

#### 字典推导式可以从任意的键值表达式中创建字典:
    >>> dt = {x: x*x for x in (1,2,3)}
    >>> dt
      {1: 1, 2: 4, 3: 9}

#### 如果关键字都是简单的字符串，有时通过关键字参数指定 key-value 对更为方便:
    >>> dabc = dict(a=1,b=3,c=5)
    >>> dabc
      {'a': 1, 'b': 3, 'c': 5}


#### 默认集合 范围for 产生
    >>> ds = {c:c*4 for c in 'apple'} 
    >>> ds
      {'a': 'aaaa', 'p': 'pppp', 'l': 'llll', 'e': 'eeee'}

    >>> ds = {c:c*4+’!’ for c in 'apple'} 
    >>> ds
     {'a': 'aaaa!', 'p': 'pppp!', 'l': 'llll!', 'e': 'eeee!'}
     
     
## 集合（set） 键key集合  支持 |并集 &交集 –补集   
    与dict类似，set也是一组key的集合，但不存储value。
    由于key不能重复，所以，在set中，没有重复的key。   
    
### 创建一个set，需要提供一个列表list作为输入集合：
    >>> s =set([1,2,3])   列表初始化集合
    >>> s
    {1, 2, 3}

### 增添删除元素
      重复元素在set中会被自动被过滤，
      通过add(key)方法往set中添加元素，重复添加不会有效果，
      通过remove(key)方法可以删除元素,
      例如：
      >>> ss = set([1,1,2,2,3,4,4,5,5,5,5,5])
      >>> ss
         {1, 2, 3, 4, 5}

      >>> ss.add(9)
      >>> ss
         {1, 2, 3, 4, 5, 9}

      >>> ss.add(1)
      >>> ss
         {1, 2, 3, 4, 5, 9}

      >>> ss.remove(1)
      >>> ss
        {2, 3, 4, 5, 9}
        
### 集合set的 交并补集操作 

    >>> s1 = set([1,2,3,4])
    >>> s1
      {1, 2, 3, 4}
    >>> s2=set([3,4,5,6,7,8,1])
    >>> s2
      {1, 3, 4, 5, 6, 7, 8}
    >>> s1 & s2         交集
      {1, 3, 4}
    >>> s1 | s2         并集
     {1, 2, 3, 4, 5, 6, 7, 8}

    >>>s2-s1            补集   无+号操作
     {8, 5, 6, 7}
     
    与dict一样，set同样不可以放入可变对象，因为无法判断两个可变对象是否相等，
    也就无法保证set内部不会有重复元素。所以把list放入set，会报错。   
     
## 条件与循环
    一、 条件if
    格式：
    if 判断条件：
        执行语句1……
    
    elif 判断条件2：
        执行语句3……
    else：
        执行语句4……
    当if有多个条件时可使用括号来区分判断的先后顺序，括号中的判断优先执行，
    
    此外 and 和 or 的优先级低于>（大于）、<（小于）等判断符号，
    即大于和小于在没有括号的情况下会比与或要优先判断。  
    
### or条件
    对or而言，Python会由左到右求算操作对象，然后返回第一个为真的操作对象。
    Python会在其找到的第一个真值操作数的地方停止，通常叫短路计算。
    >>> 3 or 2
      3

    如果左边的操作数为假（空对象），Python只会计算右边的操作数并将其返回。
    >>> [] or 5
     5 
    >>> [] or []
      []
    >>> [] or {}
      {}
  
### and 会停在第一个为假的对象上。
    >>> 3 and 2
      2
    >>> [] and 3
     []
    >>> 0 and 1
     0
    >>> 1 and 0
      0
### 神奇的布尔值
    从一个固定大小的集合中选择非空的对象，只要将其串在一个or表达式即可

    >>> X = ‘A’ or ‘B’ or ‘C’ or None
    会把X设置为 A  B C 中第一个非空的对象，或者所有都为假时，设置为None 
    
### 循环
    Python提供了for循环和while循环（在Python中没有do...while循环），
    for循环一般比while计数器循环运行得更快。
    
    break语句，在语句块执行过程中终止循环，并且跳出整个循环
    
    continue语句，在语句块执行过程中终止当前循环，跳出该次循环，执行下一次循环。
    
    pass语句，是空语句，是为了保持程序结构的完整性。不做任何事情，一般用做占位语句。
    
    循环else块，只有当循环正常离开时才会执行（也就是没有碰到break语句）
    
    
#### for 循环 遍历
    是一个通用的序列迭代器，可以遍历任何有序的序列对象内的元素。可用于字符串、列表、元组、其他内置可迭代对象等
    
##### 遍历字符串 string
    >>> for letter in 'Python':    遍历字符串 string
        print('current letter: ', letter)
    current letter:  P
    current letter:  y
    current letter:  t
    current letter:  h
    current letter:  o
    current letter:  n
    
##### 遍历列表 list  
    >>>lis = [1,2,3,4,5,6,]
    >>> for l in lis:              遍历列表 list   lis = [1,2,3,4,5,6,]
        print(l)
    1
    2
    3
    4
    5
    6
    
##### 遍历元组 tuple  
    >>> tup = ('a','b','c','d','e','f')
    >>> for t in tup:       遍历元组 tuple  tup = ('a','b','c','d','e','f')
        print(t)
    a
    b
    c
    d
    e
    f
    
#####  遍历元组列表
    >>> T = [(1,3),(2,4),(3,5),(4,6)]    遍历元组列表
    >>> for t in T:
        print(t)
    (1, 3)
    (2, 4)
    (3, 5)
    (4, 6)
##### 遍历字典
    >>> d = {'a':1,'b':2,'c':3}
    >>> for key in d:                   遍历字典
        print(key, '==>', d[key])
    a ==> 1
    b ==> 2
    c ==> 3
###### 遍历 由字典转换成的元组列表
    >>>d.items()       
        dict_items([('a', 1), ('b', 2), ('c', 3)])    字典转成 元组列表
    >>> for (key, value) in d.items():                遍历 由字典转换成的元组列表
        print(key,'==>',value)
    a ==> 1
    b ==> 2
    c ==> 3

##### 嵌套的结构可以自动解包
    >>> for ((a,b),c) in [((1,2),3),((4,5),6)]:
        print(a,b,c)
    1 2 3
    4 5 6
   
   
#### break 结束整个循环

    >>> for l in 'Python':
        if l =='y':
            break
        print(l)

     P  
     
     
#### continue 结束当前轮次循环
    >>> for l in 'Python':
        if l =='y':
            continue
        print(l)
    P
    t
    h
    o
    n
    
## 匿名函数与递归函数
### 函数
    函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。
    函数能提高应用的模块性，和代码的重复利用率。
    内置函数  abs() 
    >>> abs(-100)
    100
### 定义函数
    在Python中，定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，
    然后，在缩进块中编写函数体，函数的返回值用return语句返回。
    
    我们以自定义一个求绝对值的my_abs函数为例：
    
    >>> def my_abs(x):   定义
        if x >= 0:
            return x
        else:
            return -x
    >>> my_abs(-0)      使用
        0
    >>> my_abs(-1234)
        1234

    请注意，函数体内部的语句在执行时，一旦执行到return时，函数就执行完毕，并将结果返回。
    因此，函数内部通过条件判断和循环可以实现非常复杂的逻辑。
    如果没有return语句，函数执行完毕后也会返回结果，只是结果为None。
    return None可以简写为return。
    
### 3.函数的参数
    定义函数的时候，我们把参数的名字和位置确定下来，函数的接口定义就完成了。
    对于函数的调用者来说，只需要知道如何传递正确的参数，以及函数将返回什么样的值就够了，
    函数内部的复杂逻辑被封装起来，调用者无需了解。
    Python的函数定义非常简单，但灵活度却非常大。除了正常定义的
    
    必选参数外，还可以使用
    默认参数、
    可变参数    *args
    关键字参数   **kw
    
    使得函数定义出来的接口，不但能处理复杂的参数，还可以简化调用者的代码
    
####  3.1 默认参数
    我们仍以具体的例子来说明如何定义函数的默认参数。先写一个计算x^2的函数：
    >>> def pow(w):
        return w*w
    >>> pow(9)
    81

    把 power(x) 修改为 power(x, n)，用来计算 x^n ，说干就干：
    >>> def poww(x,n):
        res = 1
        while(n>0):
            res = res * x
            n = n -1
        return res

    >>> poww(2,1)
    2
    >>> poww(2,10)
    1024
    
    默认参数就排上用场了
    >>> def poww(x,n=2):
        res = 1
        while(n>0):
            res = res * x
            n = n -1
        return res

    >>> pow(3)
    9
    
##### 设置默认参数时，有几点要注意：
    一是必选参数在前，默认参数在后，否则Python的解释器会报错（思考一下为什么默认参数不能放在必选参数前面）；
    二是如何设置默认参数。
    当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。
    使用默认参数有什么好处？最大的好处是能降低调用函数的难度。  
    
    
#### 可变参数  传递一个list/tuple对象 外加 *号 可以省略
    在Python函数中，还可以定义可变参数。顾名思义，
    可变参数就是传入的参数个数是可变的，可以是1个、2个到任意个，还可以是0个。
    
    我们以数学题为例子，给定一组数字a，b，c……，请计算 a^2+b^2+c^2+……。
    要定义出这个函数，我们必须确定输入的参数。由于参数个数不确定，
    
    我们首先想到可以把a，b，c……作为一个 list 或 tuple 传进来，
    这样，函数可以定义如下：

    >>> def clca(obje):
        sum =0
        for n in obje:
            sum = sum + n*n
        return(sum)

    >>> clca([1,2,3,4,5])
    55
    >>> clca((1,2,3,4,5))
    55

    如果利用可变参数，我们把函数的参数改为可变参数:
    >>> def clca(*obje):
        sum =0
        for n in obje:
            sum = sum + n*n
        return(sum)
    调用函数的方式可以简化成这样：
    >>> clca(1,2,3,4,5)
    55

    定义可变参数和定义 list 或 tuple 参数相比，仅仅在参数前面加了一个 * 号。
    在函数内部，参数 numbers 接收到的是一个 tuple，因此，函数代码完全不变。
    但是，调用该函数时，可以传入任意个参数，包括 0 个参数。  
    
    如果已经有一个 list 或者 tuple，要调用一个可变参数怎么办？ 
    Python允许你在 list 或 tuple 前面加一个 * 号，
    把 list 或 tuple 的元素变成可变参数传进去,可以这样做：
    
    >>> clca(*[1,2,3])     这种写法相当有用，而且很常见。
    14

#### 关键字参数  **kw

    可变参数允许你传入 0 个或任意个参数，这些可变参数在函数调用时自动组装为一个 tuple。
    而关键字参数允许你传入 0 个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个 dict。
    请看示例：
    
    >>>def person(name, age, **kw):
        print('name: 'name, 'age:',age, 'other inf:', kw)
    >>>person('EwenW',27)
        name:  EwenW age: 27 other inf: {}

    也可以传入任意个数的关键字参数：
    
    >>>person('EwenW',27, Job='student', gender='men')
    name:  EwenW age: 27 other inf: {'Job': 'student', 'gender': 'men'}

    关键字参数有什么用？它可以扩展函数的功能。比如，在person函数里，我们保证能接收到name和age这两个参数，
    但是，如果调用者愿意提供更多的参数，我们也能收到。试想你正在做一个用户注册的功能，
    除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。  
    
#### 混合参数
    在Python中定义函数，可以用必选参数、默认参数、
    可变参数和关键字参数，这4种参数都可以一起使用，或者只用其中某些，
    但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数和关键字参数。
    >>> def fun_test(a,b,c=0,*args,**kw):
        print('a= ', a, 'b= ', b, 'c= ', c,'args= ', args, 'keyward= ',kw)

    >>> fun_test(1,2,3,'b',x=99)
        a=  1 b=  2 c=  3 args=  ('b',) keyward=  {'x': 99}

### 小结
    Python的函数具有非常灵活的参数形态，既可以实现简单的调用，
    又可以传入非常复杂的参数。
    
    默认参数一定要用不可变对象，如果是可变对象，运行会有逻辑错误！
    
    要注意定义可变参数和关键字参数的语法：
    
    *args是可变参数，args接收的是一个tuple；
    
    **kw是关键字参数，kw接收的是一个dict。
    
    以及调用函数时如何传入可变参数和关键字参数的语法：
    
    可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，
    再通过*args传入：func(*(1, 2, 3))；
    
    关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，
    再通过**kw传入：func(**{'a': 1, 'b': 2})。
    
    使用*args和**kw是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。

### 匿名函数 lambda
    python 使用 lambda 来创建匿名函数。
    
    lambda只是一个表达式，函数体比def简单很多。
    
    lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。
    
    lambda函数拥有自己的名字空间，且不能访问自有参数列表之外或全局名字空间里的参数。
    
    虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。
    
    >>> fibc=lambda n:1 if n<=2 else fibc(n-1)+fibc(n-2)
    >>> print(fib(20))

### 函数中的多态
    Python中的多态 一个操作的意义取决于被操作对象的类型
    
    >>> def times(x,y):
        return x*y
    >>> times(2,4)
    8
    >>> times('a',4)    传递了不同类型的参数
    'aaaa'
    
    交集
    def comm(s1,s2):
        return [x for x in s1 if in s2]
        
    >>> comm('python', 'con')
    ['o', 'n']

    >>> comm([1,2,3],[1,1,1])
    [1]

### 递归
        （1）递归就是在过程或函数里调用自身；
        （2）在使用递归策略时，必须有一个明确的递归结束条件，称为递归出口。
        
    递归算法一般用于解决三类问题： 
        （1）数据的定义是按递归定义的。（比如Fibonacci函数）
        （2）问题解法按递归算法实现。（回溯） 
        （3）数据的结构形式是按递归定义的。（比如树的遍历，图的搜索） 　

    递归的缺点：
        递归算法解题的运行效率较低。在递归调用的过程当中系统为每一层的返回点、
        局部量等开辟了栈来存储。递归次数过多容易造成栈溢出等。
        
#### 示例：斐波那契数列
    斐波那契数列由十三世纪意大利数学家斐波那契发现。数列中的一系列数字常被人们称之为神奇数奇异数。
    
    具体数列为：0，1，1，2，3，5，8，13，21，34，55，89，144，233等，
    
    从该数列的第三项数字开始，每个数字等于前两个相邻数字之和。
    
    而斐波那契数列中相邻两项之商就接近黄金分割数0.618，
    
    与这一数字相关的0.191（0.328/2）、0.382（1-0.618）、0.5和0.809
    
    等数字就构成了股市中关于市场时间和空间计算的重要数字。
    在金融市场的分析方法中，斐波那契数字频频出现。例如，在波浪理论中，
    一轮牛市行情可以用1个上升浪来表示，也可以用5个低一个层次的小浪来表示，
    
    还可继续细分为21个或89个小浪；在空间分析体系中，
    
    反弹行情的高度通常是前方下降趋势幅度的0.382、0.5、0.618；
    
    回调行情通常是前方上升趋势的0.382、0.5和0.618。
    
##### 使用list的append方法  返回斐波那契数列

    >>> def fibc(num):
        result = [0,1]
        for i in range(num-2):
            result.append(result[-1]+result[-2])
        return result
        
##### 返回最后一个数
    >>> def fibd(num):
        if num<=2:return 1
        else:
            return fibd(num-1)+fibd(num-2)
    使用 and 和 or
    def fiba(n):
        return 1 and n<=2 or fiba(n-1) + fiba(n-2)

    >>> fibc(5)
    [0, 1, 1, 2, 3]
    >>> fibc(15)
    [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377]
    >>> fibc(15)[13]/fibc(15)[14]
    0.6180371352785146

    >>> fiba(20)
    6765
    >>> fiba(19)/fiba(20)
    0.6180339985218034

        
        
        
        
