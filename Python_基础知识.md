
# 基本的数据类型
    在Python中，能够直接处理的数据类型有以下几种：
    
## 整数  int
    Python可以处理任意大小的整数，包括负整数，写程序的时候表述与数学上的方法一样，例如：99，-3，6666 等等。
## 浮点数 float
    浮点数也可以称为小数。叫做浮点数是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的。
    比如，1.11x106和11.1x105是完全相等的。对于很大或很小的浮点数，
    必须用科学计数法表示，把10用e替代，1.11x106就是1.11e6，或者11.1e5，0.0000011可以写成1.1e-6。
    负数的话直接在前面加负号即可，例如：-1.1e-6。
    
    需要注意的一点是，整数和浮点数在计算机内部存储的方式是不同的，整数之间的运算永远是精确的，
    而浮点数运算则可能会有四舍五入的误差。

## 字符串
    字符串是以单引号 ' 或双引号 " 括起来的任意文本' '或" "只是一种表示方式，不是字符串的一部分，
    所以字符串'rice'只有r，i，c，e这4个字符。如果要把'本身也包括进字符里，那就可以用" "括起来。
    如果字符串内部既包含 ' 又包含 " 怎么办呢？我们可以用转义字符 \ 来标识，
    如：'I\'m \"OK\"!'表示的内容为：I'm "OK"!
    转义字符\可以转义很多字符，比如\n表示换行，\t表示制表符，字符\本身也要转义，
    所以\表示的字符就是\，用print()打印字符串看看结果如何（3.0之后的版本要 + () ）：
    
    >>> print('I\'m OK')      I'm OK
    
## 布尔值
    布尔值和布尔代数的表示完全一致，一个布尔值只有True、False两种值。Python中，
    既可以直接用True、False表示（一定要大写），也可以通过布尔运算计算出来：
    >>> True
    True
    >>> 1>0
    True
    
    布尔值可以用and、or和not即 与、或和非进行运算。
    and 与 前后都为True 结果才为True  前面为False 后面的就不判断了
    or   或  前后有一个为 True 结果就为True  前面为 True后面的就不判断了
    not  非 取反  单目运算符
    
# 列表
    Python内嵌的数据类型主要包括以下两类：
    
    有序（底层红黑数存储结构）：
    
      1. List（列表） 
          是有序集合，没有固定大小，可以通过对偏移量以及其他方法修改列表大小。列表的基本形式如：[1,2,3,4]方括号
      2. Tuple（元组）
          是有序集合，是不可变的，可以进行组合和复制运算后会生成一个新的元组。元组的基本形式比如：(1,3,6,10)圆括号
      3. String（字符串）
          也是有序集合，字符串的基本形式比如：’hello’，这里不进行具体介绍。单引号 或 双引号

      List（列表） 是 Python 中最通用的序列。列表是一个任意类型对象位置的相关有序集合，它没有固定大小。
      不像字符串，其大小是可以变的，通过对偏移量进行赋值以及其他各种列表的方法进行调用，可以修改列表大小。
      
    无序（底层哈希表存储结构）：
      1. Set（集合）
        是一个无序不重复元素的集。基本功能包括关系运算和消除重复元素。集合的基本形式如：set('abracadabra')   
      2.dictionary（字典）
        是无序的键：值对  (key:value 对)集合，键必须是互不相同的(在同一个字典之内)。
        字典的基本形式如：{'jack': 4098, 'sape': 4139} 首先对列表进行介绍。
        
      索引是从0开始而非1开始！！ [ ） 左闭 右开
      
## 列表list  
    列表中值的分割用变量[头下标:尾下标]，就可以截取相应的列表，从左到右索引默认“0”开始的，从右到左索引默认-1开始，
    下标可以为空表示取到头或尾。可以对列表进行索引、切片等操作，看下面例子。
### 列出一周 可以使用list：
    >>> week = ['Monday','Tuesday','Wednesday','Thursday','Friday','Saturday','Sunday']   
    >>> week
     ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
### week是一个list，可以用len()获取其元素个数：
    >>> len(week)
      7
    可以使用索引来访问list中的每一个位置上的元素，不过一定要记住索引是从0开始的！！
    >>> week[0]
      'Monday'   
    >>> week[len(week)-1]    
      'Sunday'
      
     由于索引是从0开始的，最后一个元素的索引是列表长度 - 1。
    python支持从列表最后取元素，如果要取最后一个元素，可以用-1做索引，直接获取最后一个元素：
    >>> week[-1]
      'Sunday'
    >>> week[-7]
      'Monday'   
    
    
### 删除list末尾的元素，使用pop()方法：
    >>> week.pop()
      'Sunday'      返回被删除的元素  pop(i) 删除指定索引元素
    >>> week
      ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
      
### 由于list是一个可变的有序表，所以我们可以往list中 追加 append() 元素到末尾：
    >>> week.append('Sun')
    >>> week
      ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sun']  
      
### 还可以把元素插入 insert() 到指定的位置，比如索号为7的位置：
    >>> len(week)
      7
    >>> week.insert(7,'8')
    >>> week
      ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sun', '8']
    >>> len(week)
### 把某个元素替换成别的元素，可以直接赋值给对应的索引位置：
    >>> week[0]
      'Monday'
    >>> week[0]='1'
    >>> week[0]
      '1'
    >>> week
      ['1', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sun', '8']

### Python 的列表数据类型包含更多的方法。
    list.append(x)    把一个元素添加到列表的结尾。
    list.extend(L)    将一个给定列表中的所有元素都添加到另一个列表中。
    list.insert(i, x) 在指定位置插入一个元素。第一个参数是准备插入到其前面的那个元素的索引，
                      例如 a.insert(0, x) 会插入到整个列表之前，而 a.insert(len(a), x) 相当于 a.append(x)。
    list.remove(x) 删除列表中值为 x 的第一个元素。如果没有这样的元素，就会返回一个错误。
    list.pop([i]) 从列表的指定位置删除元素，并将其返回。如果没有指定索引，a.pop() 返回最后一个元素。
                  元素随即从链表中被删除。(方法中 i 两边的方括号表示这个参数是可选的，而不是要求你输入一对方括号，
                  这个经常会在 Python 库参考手册中遇到这样的标记。)
    list.index(x) 返回列表中第一个值为 x 的元素的索引。如果没有匹配的元素就会返回一个错误。
    list.count(x) 返回 x 在链表中出现的次数。
    list.sort(cmp=None, key=None, reverse=False) 对列表中的元素进行排序
                  参数可以用来自定义排序方法，参考 sorted() 的更详细的解释）。
    list.reverse() 就地倒排链表中的元素
    del list[i] 有个方法可以从列表中按给定的索引而不是值来删除一个子项：del 语句。
                 它不同于有返回值的 pop() 方法。语句 del 还可以从列表中删除切片或清空整个列表
                 我们以前介绍过一个方法是将空列表赋值给列表的切片 
  
  
## 元组（tuple）
    tuple是另一种有序的数据类型，与list比较类似。主要不同的一点是tuple被创建后就不能对其进行修改。
    所以，tuple与list不同，没有append(),pop(),insert()这些方法可以使用。
    获取元素的方法和list是一样的，可以通过索引来访问（也是从0开始的），只不过不能赋值成为其他的元素。
    因为tuple不可变，所以代码更安全。如果可以的话，我们尽量使用tuple代替list      
      
### 创造元组
    定义一个空的tuple，使用 () ：
    >>> t=()
    >>> t
    `()
    
    只有1个元素的元组在进行定义的时候，需要加一个逗号 , 来消除歧义，
    否则定义的就不是一个元组而是元素本身：
    >>> t=(3)
    >>> t
    `3
    >>> t=(3,)
    >>> t
    `(3, )

###   元组的连接
    如前面所说，元组是不可改的，但是可以连接
    可以使用 + 对元组进行连接，例如：
    >>> t1 =(2,3,5)
    >>> t1
     (2, 3, 5)
    >>> t2=('rice', 'mid')
    >>> t2
     ('rice', 'mid')
    >>> t3=t1+t2     底层重载了 +号运算符
    >>> t3
      (2, 3, 5, 'rice', 'mid')
      
### 元组的删除
    元组中的元素不能被删除，但是我们可以使用 del 删除整个元组，删除后可以重新定义：
    >>> t3[0]
    2
    >>> t3[0]=3  错误    >>>  del t3 
    
### 元组元素的间接修改
    事实上，上面所说的元素不变是指每个元素的指向永远不变。即指向1，就不能改成指向2，
    指向一个list，就不能改成指向其他对象，
    但指向的这个list本身是可变的，例如：
    
    >>> t4 = (1,2,[3,4,5])
    >>> t4
    (1, 2, [3, 4, 5])
    >>> t4[2][0]
    3
    >>> t4[2][0]=100
    >>> t4
    (1, 2, [100, 4, 5])

### Python 的元组数据类型包含更多的方法。
    tup.index(x, [start, [stop]])) 返回元组中start到stop索引中第一个值为 x 的元素在整个列表中的索引。
                                   如果没有匹配的元素就会返回一个错误。
    tup.count(x) 返回 x 在元组中出现的次数。
    cmp(tuple1, tuple2) 比较元组中两个元素。
    len(tuple) 计算元组元素个数。
    max(tuple) 返回元组中元素最大值。
    min(tuple) 返回元组中元素最小值。
    tuple(seq) 将列表转换为元组。
    
    元组不提供字符串、列表和字典中的方法。
    
    如果相对元组排序，通常先得将它转换为列表并使其成为一个可变对象，
    才能获得使用排序方法，或使用sorted内置方法。     
    
## 字典（dictionary）

    字典在某些语言中可能称为 联合内存 (associative memories) 或 联合数组 (associative arrays)。
    序列是以连续的整数为索引，与此不同的是，字典以"关键字"为索引，关键字可以是任意不可变类型，通常用字符串或数值。
    如果元组中只包含字符串和数字，它可以作为关键字，如果它直接或间接地包含了可变对象，就不能当做关键字。
    不能用列表做关键字，因为列表可以用索引、切割或者 append() 和 extend() 等方法改变。
    
### 字典的创建
    使用大括号创建一个空的字典：{}。
    >>> d ={}
    >>> d
      {} 
    初始化列表时，在大括号内放置一组逗号分隔的 键：值 对，
    这也是字典输出的方式。
    >>> d={'aline':50, 'dline':100}
    >>> d
     {'aline': 50, 'dline': 100}
     
    字典是无序的键：值对 (key:value 对)集合，
    键必须是互不相同的(在同一个字典之内)。      
      
### 字典的主要操作是依据键来存储 和 取值。

    >>> d['aline']
      50
    >>> d['aline'] =111
    >>> d
      {'aline': 111, 'dline': 100}   
### 用 del 来删除键：值对(key:value)，

    >>> del d['aline']
    >>> d
    {'dline': 100}
    
    >>> d['agg'] =1
    >>> d
    {'dline': 100, 'agg': 1}
    
    删除一个key，使用pop(key)方法，对应的value也会从dict中删除：
    >>> d.pop('dline')
    100
    >>> d
    {'agg': 1}


      
###  把数据放入dict还可以 

#### 直接通过key放入：
    >>> d['agg']=0.5
    >>> d
    {'dline': 100, 'agg': 0.5}

    一个key只能对应一个value，多次对一个key放入value，后面的值会把前面的值冲掉：
    >>> d['agg'] =1
    >>> d
    {'dline': 100, 'agg': 1}
    
####  如果key不存在，对key进行访问，dict就会报错。  
    要避免key不存在的错误，有两种办法，
    
    一是通过 in 判断key是否存在，
    
    二是通过dict提供的 get 方法，
    如果key不存在，可以返回None（返回None的时候Python的交互式命令行不显示结果），
    或者自己指定的value：
    >>> 'meet' in d
      False
    >>> d.get('agg')
     1
    >>> d.get('meet')
    >>> d.get('meet',20)    这种方式不会增加字典元素
      20
    >>> d
    {'dline': 100, 'agg': 1}

### 有下面几点需要注意：
    1. dict内部存放的顺序和key放入的顺序是没有关系的
    2. dict查找和插入的速度极快，不会随着key的增加而增加，但是需要占用大量的内存，内存浪费多
    3. dict的key必须是不可变对象。字符串、整数等都是不可变的，可以放心地作为key，而list是可变的，就不能作为key：

### 常见字典操作方法   
    D.clear()删除字典内所有元素
    D.copy()返回一个字典的复制
    D.fromkeys(seq,val)创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值
    D.get(key, default=None)返回指定键的值，如果值不在字典中返回default值
    D.has_key(key)如果键在字典dict里返回true，否则返回false
    
    D.items()以列表返回 可遍历的(键, 值)   元组数组
    
    D.keys()以列表返回一个字典所有的键
    D.setdefault(key, default=None)和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default
    D.update(dict2)把字典dict2的键/值对更新到dict里
    D.values()以列表返回字典中的所有值
    D.pop(key)删除一个键并返回它的值，类似于列表的pop,只不过删除的是一个键不是一个可选的位置
    del D[key]删除键
    D[key] = 42新增或修改键
    
### 字典用法注意事项：
    1. 序列运算无效，字典元素间是没有顺序的概念
    2. 对新索引赋值会添加项
    3. 键不一定总是字符串
    
### 多种构造字典方式
#### dict() 构造函数可以直接从 key-value 对中创建字典
    >>> d = dict([('frank',410),('usa',100),('cherman',200)])
    >>> d
      {'frank': 410, 'usa': 100, 'cherman': 200}

#### dict.fromkeys([‘apple’,’balala’],0)
    >>> dfruit = dict.fromkeys(['apple','balana'],0)
    >>> dfruit
      {'apple': 0, 'balana': 0}

#### zip() + dict() 方式
    >>> dalpha = dict(zip(['a','b','c'],[1,2,3]))
    >>> dalpha
      {'a': 1, 'b': 2, 'c': 3}

#### zip() + 范围for
    >>> dkv = {k:v for (k,v) in zip(['aa','bb','cc'],[11,22,33])}
    >>> dkv
      {'aa': 11, 'bb': 22, 'cc': 33} 

#### 字典推导式可以从任意的键值表达式中创建字典:
    >>> dt = {x: x*x for x in (1,2,3)}
    >>> dt
      {1: 1, 2: 4, 3: 9}

#### 如果关键字都是简单的字符串，有时通过关键字参数指定 key-value 对更为方便:
    >>> dabc = dict(a=1,b=3,c=5)
    >>> dabc
      {'a': 1, 'b': 3, 'c': 5}


#### 默认集合 范围for 产生
    >>> ds = {c:c*4 for c in 'apple'} 
    >>> ds
      {'a': 'aaaa', 'p': 'pppp', 'l': 'llll', 'e': 'eeee'}

    >>> ds = {c:c*4+’!’ for c in 'apple'} 
    >>> ds
     {'a': 'aaaa!', 'p': 'pppp!', 'l': 'llll!', 'e': 'eeee!'}
     
     
## 集合（set） 键key集合  支持 |并集 &交集 –补集   
    与dict类似，set也是一组key的集合，但不存储value。
    由于key不能重复，所以，在set中，没有重复的key。   
    
### 创建一个set，需要提供一个列表list作为输入集合：
    >>> s =set([1,2,3])   列表初始化集合
    >>> s
    {1, 2, 3}

### 增添删除元素
      重复元素在set中会被自动被过滤，
      通过add(key)方法往set中添加元素，重复添加不会有效果，
      通过remove(key)方法可以删除元素,
      例如：
      >>> ss = set([1,1,2,2,3,4,4,5,5,5,5,5])
      >>> ss
         {1, 2, 3, 4, 5}

      >>> ss.add(9)
      >>> ss
         {1, 2, 3, 4, 5, 9}

      >>> ss.add(1)
      >>> ss
         {1, 2, 3, 4, 5, 9}

      >>> ss.remove(1)
      >>> ss
        {2, 3, 4, 5, 9}
        
### 集合set的 交并补集操作 

    >>> s1 = set([1,2,3,4])
    >>> s1
      {1, 2, 3, 4}
    >>> s2=set([3,4,5,6,7,8,1])
    >>> s2
      {1, 3, 4, 5, 6, 7, 8}
    >>> s1 & s2         交集
      {1, 3, 4}
    >>> s1 | s2         并集
     {1, 2, 3, 4, 5, 6, 7, 8}

    >>>s2-s1            补集   无+号操作
     {8, 5, 6, 7}
     
    与dict一样，set同样不可以放入可变对象，因为无法判断两个可变对象是否相等，
    也就无法保证set内部不会有重复元素。所以把list放入set，会报错。   
     
## 条件与循环
    一、 条件if
    格式：
    if 判断条件：
        执行语句1……
    
    elif 判断条件2：
        执行语句3……
    else：
        执行语句4……
    当if有多个条件时可使用括号来区分判断的先后顺序，括号中的判断优先执行，
    
    此外 and 和 or 的优先级低于>（大于）、<（小于）等判断符号，
    即大于和小于在没有括号的情况下会比与或要优先判断。  
    
### or条件
    对or而言，Python会由左到右求算操作对象，然后返回第一个为真的操作对象。
    Python会在其找到的第一个真值操作数的地方停止，通常叫短路计算。
    >>> 3 or 2
      3

    如果左边的操作数为假（空对象），Python只会计算右边的操作数并将其返回。
    >>> [] or 5
     5 
    >>> [] or []
      []
    >>> [] or {}
      {}
  
### and 会停在第一个为假的对象上。
    >>> 3 and 2
      2
    >>> [] and 3
     []
    >>> 0 and 1
     0
    >>> 1 and 0
      0
 
    
